# Car-Navigation-Dijkstra-Implementation

The project consists in the implementation of a program for finding the shortest path between 2 points and the time in which it is traveled in the form of the total cost of the nodes crossed from the beginning node to the end node. For implementation I used Dijkstra algorithm.
The vehicles driven by customers can be bicycles (b), motorcycles (m), cars (a), trucks (c).The city map is represented by a series of points and streets that can be transposed as a graph in which points are the nodes, and the streets are the edges. Each node has an associated name. Every street has associated name, cost and a number of traffic restrictions. Speed and size restrictions are available when creating the map, but traffic jams may occur after.Traffic jams are associated with a single street, but there can be several traffic jams on the same street. A car can drive on the street if it has a size less than or equal to the size limit on the street.
For the realization of the project I created the following classes:
 The Node class that has the role of retaining information about the node such as its name which is an int, the cost of the node from the start to it, a queue in which we have the nodes traversed from the source node to the current node without current node and the map that includes at the key, the names of the neighboring nodes and at the value, the costs associated with the respective roads between the two nodes.
 The Street class which consists of pctStart and pctDest represented as int values, a size limit for the respective street, an additional cost which represents the cost of the street and a traffic jam vector that retains the costs related to traffic jams that might appear on the street.
 The HartaOras(the city map) class in which I created a vector of nodes and one of streets, also the constructor that initializes the two vectors, the constructor that creates an object of the HartaOras type by copying the information from the map received as a parameter.
 I also used here the addStreet method which adds a street to the map, the addRestriction method which adds a restriction in the form of a cost on a street as well as the drive method which returns the waypoints from pctStart to pctDest and the cost between them.I also used the getNodeByName method to return the node (point) I was looking for from the nodes vector if it exists or null otherwise. Using the getStradBYName () method I returned the street from the streets vector if it found it or null otherwise.
 The Vehicle class I implemented has defined a type representing the vehicle name, the specific size of a vehicle, as well as its cost, and also the manufacturer without parameters and the one with parameters of the class that sets the attributes of an object of Vehicle type. (In the implementation I also used getters and setters related to all the attributes of the class). I used the abstraction within the Vehicle class which is extended by the other types of vehicles for which I created the Automobile, Bicycle, Truck, Motorcycle classes. I used inheritance in the classes Car, Bicycle, Truck, Motorcycle because I wanted to take over the methods and attributes from the parent class (Vehicle) these (attributes) being common in all 4 classes. I used polymorphism in the constructors in the Node class and in the Street class for example where I have both constructor without parameters and with parameters.
